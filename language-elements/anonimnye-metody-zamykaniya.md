# Анонимные методы / Замыкания

```csharp
(a) => { stdout.printf("%d\n", a); }
```

Анонимный метод, также известный, как лямбда-выражение, функциональный литерал или замыкание, может быть определен в Vala при помощи оператора `=>`. Список параметров должен находиться слева от оператора, а тело метода - справа.

Анонимный метод сам по себе не имеет смысла. Он полезен только если вы присваиваете его переменной типа делегат или передаете его в качестве аргумента в другой метод.

Обратите внимание, что ни тип параметра ни тип возвращаемого значения не заданы явно. Вместо этого типы определяются по сигнатуре делегата, которому присваивается метод.

Присваивание анонимного метода делегату.

```csharp
delegate void PrintIntFunc(int a);

void main() {
    PrintIntFunc p1 = (a) => { stdout.printf("%d\n", a); };
    p1(10);

    // Фигурные скобки не обязательны, если тело содержит одно выражение.
    PrintIntFunc p2 = (a) => stdout.printf("%d\n", a);
    p2(20):
}
```

Пересылка анонимных методов в другие методы:

```csharp
delegate int Comparator(int a, int b);

void my_sorting_algorithm(int[] data, Comparator compare) {
    // ... 'сравнение' происходит где-то здесь ...
}

void main() {
    int[] data = { 3, 9, 2, 7, 5 };
    // Анонимный метод передается в качестве второго аргумента:
    my_sorting_algorithm(data, (a, b) => {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    });
}
```

Анонимные методы поддерживают замыкания. Это значит, что вы можете получить доступ к переменным внешнего метода, внутри лямбда-выражения:

```csharp
delegate int IntOperation(int i);

IntOperation curried_add(int a) {
    return (b) => a + b;  //  'a' - внешняя переменная
}

void main() {
    stdout.printf("2 + 4 = %d\n", curried_add(2)(4));
}
```

В этом примере curried\_add \(смотрите Каррирование\) возвращает новосозданный метод, который сохраняет значение a. Это возвращённый метод вызывается затем с аргументом 4, выдавая в качестве результата сумму двух чисел.

